# 单选题

1. 阅读下面代码

```c#
class Program
{
    public static void ThrowException()
    {
        throw new Exception();
    }

    static void Main(string[] args)
    {
        try
        {
            Console.WriteLine("try");
            ThrowException();
        }
        catch
        {
            Console.WriteLine("catch");
        }
        finally
        {
            Console.WriteLine("finally");
        }
        Console.Read();
    }
}
```

请问代码运行结果是：( A )

A.   try / catch / finally

B.    try 

C.    try / catch

D.   try / finally

:pencil:异常处理的执行步骤

2. 阅读下面的代码

```c#
public struct Rect
{
    public int e;
}
class Program
{
    public int d = 4;

    public static void SetValue(int a, ref int b, out int c, Program p, Rect r)
    {
        a = 5;
        b = 6;
        c = 7;
        p.d = 8;
        r.e = 9;
    }
    static void Main(string[] args)
    {
        int a = 1;
        int b = 2;
        int c = 3;
        Program p = new Program();
        p.d = 4;
        Rect r = new Rect();
        r.e = 5;
        SetValue(a, ref b, out c, p, r);
        Console.WriteLine("a={0},b={1},c={2},p.d={3},r.e={4}", a, b, c, p.d, r.e);
        Console.Read();
    }
}
```

请问程序输出结果是（C）

A.   a=1, b=2, c=3, p.d=4, r.e=5

B.    a=5, b=2, c=7, p.d=8, r.e=9

C.    a=1, b=6, c=7, p.d=8, r.e=5

D.   a=1, b=6, c=3, p.d=4, r.e=9

:pencil:a 在 Main 函数作用域中已经被赋值为1，SetValue 不会改变 Main函数作用域的 a 的值；ref 和 out 关键字都是表示参数按引用传递，值类型的参数也是如此，也就是说 SetValue 中对 b 和 c 进行赋值之后，Main函数中 b 和 c 也随之改变；参数 p 是引用类型，p.d 被赋值为8；参数 r 为值类型，r.e 在 SetValue 作用域下被改变，但不影响 Main 作用域下的 r.e 的值；

3. 阅读下面的代码

```c#
public abstract class Animal
{
    public Animal()
    {
        Console.WriteLine("New Animal");
    }
    public virtual void Shout()
    {
        Console.WriteLine("Animal Shout");
    }
}

public class Dog : Animal
{
    public Dog()
    {
        Console.WriteLine("New Dog");
    }
    public override void Shout()
    {
        Console.WriteLine("Dog Shout");
    }
    static void Main(string[] args)
    {
        Animal animal = new Dog();
        animal.Shout();
        Console.Read();
    }
}
```

请问程序输出结果是（C）

A.   Dog Shout / Dog Shout

B.    New Dog / Animal Shout

C.    New Animal / New Dog / Dog Shout

D.   New Dog / New Animal / Animal Shout

:pencil: class 继承：代码 `Animal animal = new Dog();` 执行时，构造函数的执行顺序，父类构造函数先执行，子类构造函数后执行，所以先打印 New Animal ，后打印 New Dog；对父类的 virtual 方法重写 override ，实际执行的是 `Dog.Shout();`