# 单选题

1. 阅读下面代码

```c#
class Program
{
    public static void ThrowException()
    {
        throw new Exception();
    }

    static void Main(string[] args)
    {
        try
        {
            Console.WriteLine("try");
            ThrowException();
        }
        catch
        {
            Console.WriteLine("catch");
        }
        finally
        {
            Console.WriteLine("finally");
        }
        Console.Read();
    }
}
```

请问代码运行结果是：( A )

A.   try / catch / finally

B.    try 

C.    try / catch

D.   try / finally

:pencil:异常处理的执行步骤

2. 阅读下面的代码

```c#
public struct Rect
{
    public int e;
}
class Program
{
    public int d = 4;

    public static void SetValue(int a, ref int b, out int c, Program p, Rect r)
    {
        a = 5;
        b = 6;
        c = 7;
        p.d = 8;
        r.e = 9;
    }
    static void Main(string[] args)
    {
        int a = 1;
        int b = 2;
        int c = 3;
        Program p = new Program();
        p.d = 4;
        Rect r = new Rect();
        r.e = 5;
        SetValue(a, ref b, out c, p, r);
        Console.WriteLine("a={0},b={1},c={2},p.d={3},r.e={4}", a, b, c, p.d, r.e);
        Console.Read();
    }
}
```

请问程序输出结果是（C）

A.   a=1, b=2, c=3, p.d=4, r.e=5

B.    a=5, b=2, c=7, p.d=8, r.e=9

C.    a=1, b=6, c=7, p.d=8, r.e=5

D.   a=1, b=6, c=3, p.d=4, r.e=9

:pencil:a 在 Main 函数作用域中已经被赋值为1，SetValue 不会改变 Main函数作用域的 a 的值；ref 和 out 关键字都是表示参数按引用传递，值类型的参数也是如此，也就是说 SetValue 中对 b 和 c 进行赋值之后，Main函数中 b 和 c 也随之改变；参数 p 是引用类型，p.d 被赋值为8；参数 r 为值类型，r.e 在 SetValue 作用域下被改变，但不影响 Main 作用域下的 r.e 的值；

3. 阅读下面的代码

```c#
public abstract class Animal
{
    public Animal()
    {
        Console.WriteLine("New Animal");
    }
    public virtual void Shout()
    {
        Console.WriteLine("Animal Shout");
    }
}

public class Dog : Animal
{
    public Dog()
    {
        Console.WriteLine("New Dog");
    }
    public override void Shout()
    {
        Console.WriteLine("Dog Shout");
    }
    static void Main(string[] args)
    {
        Animal animal = new Dog();
        animal.Shout();
        Console.Read();
    }
}
```

请问程序输出结果是（C）

A.   Dog Shout / Dog Shout

B.    New Dog / Animal Shout

C.    New Animal / New Dog / Dog Shout

D.   New Dog / New Animal / Animal Shout

:pencil: class 继承：代码 `Animal animal = new Dog();` 执行时，构造函数的执行顺序，父类构造函数先执行，子类构造函数后执行，所以先打印 New Animal ，后打印 New Dog；对父类的 virtual 方法重写 override ，实际执行的是 `Dog.Shout();`

4. 阅读下面的代码

```c#
class A
{
    public static int X = 2;
    static A()
    {
        X = B.Y + 1;
    }
}
class B
{
    public static int Y = A.X + 1;
    static B() { }
    static void Main()
    {
        Console.WriteLine("X={0},Y={1}", A.X, B.Y);
        Console.Read();
    }
}
```

请问程序输出结果是（A）

A.   X=1, Y=2

B.    X=2, Y=2

C.    X=2, Y=1

D.   X=1, Y=1

:pencil: 使用尚未声明的 `static` 字段来初始化另一个 `static` 字段时，在向 `static` 字段显式赋值之后才会定义结果。即调用 A.X 时，执行静态构造函数，未对 B.Y 显示赋值，则在构造函数 A 执行时 B.Y 为 0，X = 0 + 1 = 1；调用 B.Y 时，A.X 值为1，则 B.Y 的值为2 。

5. 在WinForm中，Form从创建到释放会依次触发的事件顺序是（A）

A.   构成函数->Load->Activated->Closing->Closed->Deactivate

B.    构成函数-> Activated -> Load ->Closing-> Deactivate-> Closed 

C.    Load->构成函数->Activated->Closing->Closed->Deactivate

D.   Load->构成函数->Activated-> Closing -> Deactivate -> Closed

6. 对于CSS position 属性，下面正确的说法是（B）

A.   盒子的默认定位为fixed，即固定定位

B.    盒子的相对定位是指相对于其身原有位置进行偏移，一般会结合left、 right、top、bottom属性使用

C.    绝对定位是以其父元素为参考对象，绝对定位的元素会脱离文档流

D.   position属性的取值为static时，是以浏览器窗口作为定位基准